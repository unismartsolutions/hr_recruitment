-- Initialize HR Recruitment System Database

-- Create extensions
CREATE EXTENSION IF NOT EXISTS "uuid-ossp";

-- Try to create pg_trgm extension (if it fails, we'll use alternative indexing)
DO $$
BEGIN
    CREATE EXTENSION IF NOT EXISTS "pg_trgm";
    EXCEPTION WHEN OTHERS THEN
    RAISE NOTICE 'pg_trgm extension not available. Using alternative indexing.';
END $$;

-- Drop tables if they exist (for clean initialization)
DROP TABLE IF EXISTS candidates;
DROP TABLE IF EXISTS users;

-- Create users table
CREATE TABLE users (
    id SERIAL PRIMARY KEY,
    username VARCHAR(64) UNIQUE NOT NULL,
    email VARCHAR(120) UNIQUE NOT NULL,
    password_hash VARCHAR(256) NOT NULL,
    is_admin BOOLEAN DEFAULT FALSE,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

-- Create candidates table
CREATE TABLE candidates (
    id SERIAL PRIMARY KEY,
    name VARCHAR(100) NOT NULL,
    email VARCHAR(120) UNIQUE,
    phone VARCHAR(20),
    age INTEGER,
    education TEXT,
    skills VARCHAR[] DEFAULT '{}',  -- PostgreSQL array type
    experience TEXT,
    experience_level VARCHAR(20),  -- Junior, Mid, Senior
    industry VARCHAR(100),
    certifications VARCHAR[] DEFAULT '{}',  -- CA, CIMA, CFA, etc.
    resume_path VARCHAR(255),  -- Path to stored resume
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    created_by INTEGER REFERENCES users(id)
);

-- Create indexes for better search performance
CREATE INDEX idx_candidates_email ON candidates(email);
CREATE INDEX idx_candidates_experience_level ON candidates(experience_level);
CREATE INDEX idx_candidates_industry ON candidates(industry);
CREATE INDEX idx_candidates_name ON candidates(name);

-- Create search function for array to string conversion
CREATE OR REPLACE FUNCTION array_to_string_immutable(anyarray, text) 
RETURNS text AS $$ 
    SELECT array_to_string($1, $2); 
$$ LANGUAGE SQL IMMUTABLE;

-- Create indexes based on available extensions
DO $$
DECLARE
    trgm_exists BOOLEAN;
BEGIN
    -- Check if pg_trgm extension is available
    SELECT EXISTS (
        SELECT 1 FROM pg_extension WHERE extname = 'pg_trgm'
    ) INTO trgm_exists;

    -- If pg_trgm is available, create GIN indexes with trigram support
    IF trgm_exists THEN
        EXECUTE 'CREATE INDEX idx_candidates_skills ON candidates 
                USING gin (array_to_string_immutable(skills, '','') gin_trgm_ops)';
        
        EXECUTE 'CREATE INDEX idx_candidates_certifications ON candidates 
                USING gin (array_to_string_immutable(certifications, '','') gin_trgm_ops)';
    ELSE
        -- Otherwise, create standard btree indexes
        EXECUTE 'CREATE INDEX idx_candidates_skills ON candidates 
                USING btree (array_to_string_immutable(skills, '',''))';
        
        EXECUTE 'CREATE INDEX idx_candidates_certifications ON candidates 
                USING btree (array_to_string_immutable(certifications, '',''))';
    END IF;
END $$;

-- Create default admin user
INSERT INTO users (username, email, password_hash, is_admin)
VALUES (
    'admin', 
    'admin@example.com', 
    -- This is a hashed version of 'admin123' - you should change this in production
    'pbkdf2:sha256:150000$abc123$ab1234567890abcdef1234567890abcdef1234567890abcdef1234567890abcd', 
    TRUE
);

-- Add trigger to update 'updated_at' timestamp
CREATE OR REPLACE FUNCTION update_modified_timestamp()
RETURNS TRIGGER AS $$
BEGIN
    NEW.updated_at = CURRENT_TIMESTAMP;
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER update_candidates_modtime
BEFORE UPDATE ON candidates
FOR EACH ROW EXECUTE FUNCTION update_modified_timestamp();

-- Note: The actual hashed password should be generated by the application
-- This SQL is meant to be a template and would typically be run through
-- the application where proper password hashing would occur.
